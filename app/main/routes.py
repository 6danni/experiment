from datetime import datetime
from flask import render_template, flash, redirect, url_for, request, g, \
    jsonify, current_app, send_from_directory
import os
import random
import itertools
import re
import math
import csv
from config import Config
import firebase_admin
from firebase_admin import credentials
from firebase_admin import db as rtdb
# from app import db
# from app.models import User, Post
from app.main import bp
from .pair import _ensure_comparison_trials, _trial_at
# from firebase_admin.db import ServerValue

# @bp.route('/<string:page_name>')
# def static_page(page_name):
#     print('GET: ' + '%s.html' % ('/experiment/' + page_name))
#     return render_template('%s.html' % ('/experiment/' + page_name))

@bp.before_app_request
def _stash_pid_from_query():
    pid = request.args.get("pid")
    if pid:
        g.pid = pid

def url_for_pid(endpoint, **values):
    if "pid" not in values and getattr(g, "pid", None):
        values["pid"] = g.pid
    return url_for(endpoint, **values)

bp.add_app_template_global(url_for_pid, name="url_for_pid")

@bp.app_context_processor
def _inject_pid():
    return {"pid": getattr(g, "pid", None)}

@bp.route('/scenarios.json')
def serve_scenarios():
    return send_from_directory('static', 'scenarios.json')

@bp.route('/', methods=['GET', 'POST'])
def root():
    return redirect("/test")

@bp.route('/test')
def test():
    return 'Server is running'

@bp.get("/api/catalog/scenarios")     # keep a pure-JSON API too (nice for fetch)
def api_scenarios():
    data = rtdb.reference("/catalog/scenarios").get() or {}
    items = [{"id": k, **v} if isinstance(v, dict) else {"id": k, "value": v}
             for k, v in (data.items() if isinstance(data, dict) else [])]
    return jsonify(items), 200

# SCENARIOS_PATH = "/catalog/scenarios"
# COUNTS_PATH    = "/metrics/scenario_counts"
# ASSIGN_PATH    = "/assignments"
# PARTIC_PATH    = "/participants"

# def _list_scenarios():
#     data = rtdb.reference(SCENARIOS_PATH).get() or {}
#     if not isinstance(data, dict) or not data:
#         raise RuntimeError("No scenarios available.")
#     return data  # {scenario_id: {...}}

# def server_ts(): 
#     return {".sv": "timestamp"}


SCENARIOS_PATH = "/catalog/scenarios"
TRIALS_PATH    = "/catalog/trials"
COUNTS_SCEN    = "/metrics/scenario_counts"
COUNTS_TRIAL   = "/metrics/trial_counts"
ASSIGN_PATH    = "/assignments"
PARTIC_PATH    = "/participants"

def server_ts():
    return {".sv": "timestamp"}

def _list_scenarios():
    data = rtdb.reference(SCENARIOS_PATH).get() or {}
    if not isinstance(data, dict) or not data:
        raise RuntimeError("No scenarios available.")
    return data  # {sid: {...}}

def _list_trials():
    data = rtdb.reference(TRIALS_PATH).get() or {}
    if not isinstance(data, dict) or not data:
        raise RuntimeError("No trials available.")
    return data  # {tid: {...}}

def _create_participant_pid():
    ref = rtdb.reference(PARTIC_PATH).push({
        "created": server_ts(),
    })
    return ref.key  # <-- this is your pid, generated by RTDB
    

def _choose_and_increment_one(path, candidate_ids):
    chosen = {"id": None}
    counts_ref = rtdb.reference(path)

    def txn(curr):
        curr = curr or {}
        for cid in candidate_ids:
            curr.setdefault(cid, 0)

        min_count = min(curr[cid] for cid in candidate_ids)
        pool = [cid for cid in candidate_ids if curr[cid] == min_count]
        cid = random.choice(pool)
        curr[cid] += 1
        chosen["id"] = cid
        return curr

    counts_ref.transaction(txn)
    return chosen["id"]
    
@bp.get("/0_landing")
def page_0_landing():
    return render_template(
        "experiment/0_landing.html",
    )


def assign_participant(pid: str, n_trials: int = 30) -> tuple[str, list[str]]:
    """Assign a balanced scenario and n balanced trials, persist under /assignments/{pid}."""
    scenarios = _list_scenarios()
    trials    = _list_trials()
    sid = _choose_and_increment_one(COUNTS_SCEN, list(scenarios.keys()))

    chosen_trials: list[str] = []
    candidate_tids = list(trials.keys())
    for _ in range(n_trials):
        tid = _choose_and_increment_one(COUNTS_TRIAL, candidate_tids)
        chosen_trials.append(tid)

    # Persist both (multi-location write)
    rtdb.reference("/").update({
        f"{ASSIGN_PATH}/{pid}": {
            "scenario_id": sid,
            "trial_ids": chosen_trials,
        },
        f"{PARTIC_PATH}/{pid}/assigned": {
            "scenario_id": sid,
            "trial_ids": chosen_trials,
            "ts": server_ts(),
        },
    })
    return sid, chosen_trials

def get_assignment(pid: str) -> tuple[str | None, list[str] | None]:
    """Fetch scenario_id and trial_ids for this pid."""
    doc = rtdb.reference(f"{ASSIGN_PATH}/{pid}").get() or {}
    return (doc.get("scenario_id"), doc.get("trial_ids"))

@bp.get("/1_scenario")
def page_1_scenario():
    pid = request.args.get("pid")
    if not pid:
        # First visit → create pid, assign scenario+trials, then canonicalize URL
        pid = _create_participant_pid()
        scenario_id, trial_ids = assign_participant(pid, n_trials=30)
        return redirect(url_for("main.page_1_scenario", pid=pid), code=302)

    # Has pid → use existing assignment or assign now if missing
    scenario_id, trial_ids = get_assignment(pid)
    if not scenario_id or not trial_ids:
        scenario_id, trial_ids = assign_participant(pid, n_trials=30)

    # Load scenario object for display
    scenario = rtdb.reference(f"{SCENARIOS_PATH}/{scenario_id}").get() or {}

    # (Optional) also load trial objects if page 1 needs them immediately:
    # trials_catalog = _list_trials()
    # selected_trials = [trials_catalog[tid] for tid in trial_ids]

    return render_template(
        "experiment/1_scenario.html",
        pid=pid,
        scenario_id=scenario_id,
        scenario=scenario,
        trial_ids=trial_ids,
        total_trials=len(trial_ids),
        # trials=selected_trials,  # uncomment if you want full objects client-side
    )

@bp.get("/2_WTP_task")
def page_2_WTP_task():
    # print("yes here")
    pid = request.args.get("pid")
    if not pid:
        # No pid? Send them to /1_scenario to mint and assign.
        return redirect(url_for("main.page_1_scenario"), code=302)

    scenario_id, trial_ids = get_assignment(pid)
    if not scenario_id:
        # Edge case: pid exists but no assignment yet
        scenario_id, trial_ids = assign_participant(pid, n_trials=30)

    scenario = rtdb.reference(f"{SCENARIOS_PATH}/{scenario_id}").get() or {}
    
    return render_template(
        "experiment/2_WTP_task.html",
        pid=pid,
        scenario_id=scenario_id,
        scenario=scenario,
        trial_ids=trial_ids,
        total_trials=len(trial_ids),
    )

@bp.get("/3_LLM_task")
def page_3_LLM_task():
    # print("yes here3")
    pid = request.args.get("pid")
    if not pid:
        # No pid? Send them to /1_scenario to mint and assign.
        return redirect(url_for("main.page_1_scenario"), code=302)

    scenario_id, trial_ids = get_assignment(pid)
    if not scenario_id:
        # Edge case: pid exists but no assignment yet
        scenario_id, trial_ids = assign_participant(pid, n_trials=30)

    scenario = rtdb.reference(f"{SCENARIOS_PATH}/{scenario_id}").get() or {}
    
    return render_template(
        "experiment/3_LLM_task.html",
        pid=pid,
        scenario_id=scenario_id,
        scenario=scenario,
        trial_ids=trial_ids,
        total_trials=len(trial_ids),
    )


@bp.get("/2_WTP_task_trial")
def page_2_WTP_task_trial():
    pid = request.args.get("pid")
    if not pid:
        # No pid? Send them to scenario page to mint pid/assignment.
        return redirect(url_for("main.page_1_scenario"), code=302)

    scenario_id, trial_ids = get_assignment(pid)
    if not scenario_id or not trial_ids:
        # Edge case: somehow no assignment yet
        scenario_id, trial_ids = assign_participant(pid, n_trials=30)

    scenario = rtdb.reference(f"{SCENARIOS_PATH}/{scenario_id}").get() or {}
    total = len(trial_ids)

    # Progress: either 'last_trial' or derive from responses count
    last = rtdb.reference(f"{PARTIC_PATH}/{pid}/scenarios/{scenario_id}/last_trial").get() or 0
    current_idx = int(last) + 1  # 1-based

    if current_idx > total:
        # All trials complete → go to the next page
        return redirect(url_for("main.page_2_WTP_task", pid=pid), code=302)

    # Load current trial object (e.g., catalog/trials/t015)
    current_tid = trial_ids[current_idx - 1]
    trial_obj = rtdb.reference(f"{TRIALS_PATH}/{current_tid}").get() or {}

    return render_template("experiment/2_WTP_task_trial.html",
                           pid=pid,
                           scenario_id=scenario_id,
                           scenario=scenario,
                           trial_id=current_tid,
                           trial_index=current_idx,
                           total_trials=total,
                           trial=trial_obj)

@bp.get("/3_LLM_task_chat")
def page_3_LLM_task_chat():
    print("yes here3")
    pid = request.args.get("pid")
    if not pid:
        # No pid? Send them to /1_scenario to mint and assign.
        return redirect(url_for("main.page_1_scenario"), code=302)

    scenario_id, trial_ids = get_assignment(pid)
    if not scenario_id:
        # Edge case: pid exists but no assignment yet
        scenario_id, trial_ids = assign_participant(pid, n_trials=30)

    scenario = rtdb.reference(f"{SCENARIOS_PATH}/{scenario_id}").get() or {}
    
    return render_template(
        "experiment/3_LLM_task_chat.html",
        pid=pid,
        scenario_id=scenario_id,
        scenario=scenario,
        trial_ids=trial_ids,
        total_trials=len(trial_ids),
    )


@bp.get("/4_comparison")
def page_4_comparison():
    print("44")
    pid = request.args.get("pid")
    if not pid:
        # No pid? Send them to /1_scenario to mint and assign.
        return redirect(url_for("main.page_1_scenario"), code=302)

    scenario_id, trial_ids = get_assignment(pid)
    if not scenario_id:
        # Edge case: pid exists but no assignment yet
        scenario_id, trial_ids = assign_participant(pid, n_trials=30)

    scenario = rtdb.reference(f"{SCENARIOS_PATH}/{scenario_id}").get() or {}
    
    return render_template(
        "experiment/4_comparison.html",
        pid=pid,
        scenario_id=scenario_id,
        scenario=scenario,
        trial_ids=trial_ids,
        total_trials=len(trial_ids),
    )


@bp.post("/api/trials")
def save_trial():
    body = request.get_json(silent=True) or {}
    pid         = body.get("pid")
    scenario_id = body.get("scenario_id")
    trial_idx   = body.get("trial")        # 1-based index
    bid         = body.get("bid")

    if not pid or not scenario_id or not trial_idx or bid is None:
        return jsonify(error="BadRequest", detail="pid, scenario_id, trial, bid required"), 400

    # Persist response under participant
    # print(bid)
    base = f"{PARTIC_PATH}/{pid}/scenarios/{scenario_id}"
    rtdb.reference(f"{base}/trials/{int(trial_idx)}").update({
        "bid": float(bid),
        "ts": server_ts()
    })

    # Advance progress marker
    rtdb.reference(f"{base}/last_trial").set(int(trial_idx))

    return jsonify(ok=True), 200

@bp.get("/4_comparison_trial")
def page_4_comparison_trial():
    pid = request.args.get("pid")
    if not pid:
        return redirect(url_for("main.page_1_scenario"), code=302)

    # Ensure we have an assignment to know scenario_id
    scenario_id, trial_ids = get_assignment(pid)
    if not scenario_id or not trial_ids:
        scenario_id, trial_ids = assign_participant(pid, n_trials=30)

    # Seed comparison trials once, under /assignments/{pid}/comparison_trials
    _ensure_comparison_trials(pid, scenario_id, n=20)

    base_assign = f"{ASSIGN_PATH}/{pid}"
    last = rtdb.reference(f"{base_assign}/last_comparison_trial").get() or 0
    #trial_index = int(last)+1
    trial_index = int(last) + 1
    trials_node = rtdb.reference(f"{base_assign}/comparison_trials").get() or {}
    print(trials_node)
    print("-++++++++")
    print(trials_node[trial_index])
    # trial, total = _trial_at(trials_node, trial_index)
    # print(trial)
    # print(trial_index)
    # print()
    total = 20
    if trial_index > total:
        # All done → go to the summary/next page
        return redirect(url_for("main.page_0_landing", pid=pid), code=302)

    # You can still show the scenario header if you like
    scenario = rtdb.reference(f"{SCENARIOS_PATH}/{scenario_id}").get() or {}
    prior_decision = None
    if last >= 1:
        prior_decision = rtdb.reference(f"{base_assign}/decisions/{last}").get()

    return render_template(
        "experiment/4_comparison_trial.html",
        pid=pid,
        scenario_id=scenario_id,
        scenario=scenario,
        trial=trials_node[trial_index],
        trial_index=trial_index,
        total_trials=total,
        prior_decision=prior_decision,   # <— add this
    )

@bp.post("/api/prefs")
def save_pref():
    body = request.get_json(silent=True) or {}
    print(body)
    pid         = (body.get("pid") or "").strip()
    scenario_id = (body.get("scenario_id") or "").strip()
    trial_idx   = body.get("trial")
    choice      = (body.get("choice") or "").strip()   # "A" | "B"
    a_features  = body.get("option_a") or {}
    b_features  = body.get("option_b") or {}
    # print(a_features)
    # print('saved')
    if not pid or not trial_idx or choice not in {"A", "B"}:
        return jsonify(error="BadRequest", detail="pid, trial, and choice (A/B) required"), 400

    base_assign = f"{ASSIGN_PATH}/{pid}"
    # print(chosen)
    chosen = a_features if choice == "A" else b_features
    print("--------")
    print(chosen)
    # Pull out common fields for quick querying
    chosen_rec   = chosen.get("recommendation") or chosen.get("recommended_by")
    chosen_freq  = chosen.get("frequency")
    chosen_miss  = chosen.get("missing") or chosen.get("missing_rate")
    chosen_cov   = chosen.get("coverage")

    rtdb.reference(f"{base_assign}/comparison_trials/{int(trial_idx)}").update({
        "scenario_id": scenario_id or None,
        "choice": choice,
        "option_a": a_features,        # keep full snapshot for audit
        "option_b": b_features,
        "chosen": chosen,              # quick access to chosen feature set
        "chosen_recommendation": chosen_rec,
        "chosen_frequency": chosen_freq,
        "chosen_missing": chosen_miss,
        "chosen_coverage": chosen_cov,
        "answered_ts": server_ts(),
    })

    rtdb.reference(f"{base_assign}/last_comparison_trial").set(int(trial_idx))
    return jsonify(ok=True), 200


